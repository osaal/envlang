(*** TERMINALS ***)
(* Graphemes from the Unicode set

   Parsing: `UnicodeSegmentation::Graphemes()`
   See http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
*)
letter = ? Unicode grapheme ?;

(* ASCII digits excluding zero

   Parsing: See digit-zero
*)
digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

(* ASCII digits including zero

   Parsing: NYI
   Use UnicodeSegmentation::unicode_words()
*)
digit-zero = "0" | digit;

(* Valid non-arithmetic symbols

   Parsing: NYI
*)
generic-symbol = "-" | "_";

(* Valid arithmetic and set operator symbols

   Note: The multiplication symbol "*" is shared with the wildcard symbol "*"

   Parsing: NYI
*)
arithmetic-operator = "+" | "-" | "*" | "/" | "%" | "^";

(* Environment terminator

   A terminator is used to terminate a non-embraced-enclosed environment
   A terminator is optional if environment scope is embrased

   Parsing: NYI
*)
terminator = ";";

(* Accessor symbol

   The accessor symbol is used to access environment members
   The accessor symbol is a period "." followed by a valid identifier
   The accessor symbol is not considered valid outside of environment contexts

   Parsing: NYI
*)
accessor = ".";

(* Decimal point

   The decimal point is used to define decimal numbers
   The decimal point is not considered valid outside of floating-point numbers
*)
decimal = ".";

(* Assignment symbol

   The assignment symbol is used to assign values to identifiers

   Parsing: NYI
*)
assignment = "=";

(* Escape symbol

   The escape symbol escapes other symbols inside strings

   Parsing: NYI
*)
escape = "\\";

(* String-specific symbols

   The double and single quotes may be used to define strings

   Parsing: NYI
*)
double-quote = "\"";
single-quote = "'";

(* Separator symbol

   The separator symbol separates elements in function arguments, inheritance arguments, and return values

   Parsing: NYI
*)
separator = ",";

(* Wildcard symbol

   The wildcard is used to inherit all environments or return all values
   The wildcard symbol is only valid in inheritance arguments and function return values
   The symbol is shared with the multiplication operator (see arithmetic-operator)

   Parsing: NYI
*)
wildcard = "*";

(* Environment operators

   Environments are defined by a start and end operator

   Parsing: NYI
*)
environment-start-operator = "{";
environment-end-operator = "}";
environment-operators = environment-start-operator | environment-end-operator;

(* Inheritance operators

   Inheritance arguments are defined by a start and end operator

   Parsing: NYI
*)
inheritance-argument-start-operator = "(";
inheritance-argument-end-operator = ")";
inheritance-argument-operators = inheritance-argument-start-operator | inheritance-argument-end-operator;

(* Function argument operators

   Function arguments are defined by a start and end operator

   Parsing: NYI
*)
function-argument-start-operator = "[";
function-argument-end-operator = "]";
function-argument-operators  = function-argument-start-operator | function-argument-end-operator;

(* All symbols

   Defines all reserved symbols used in the language
   This does not contain the generic symbols, which are free to be used in identifiers

   Parsing: NYI
*)
symbol =
   arithmetic-operator
   | terminator
   | accessor
   | assignment
   | double-quote
   | single-quote
   | separator
   | wildcard
   | escape
   | environment-operators
   | inheritance-argument-operators
   | function-argument-operators;

(*** KEYWORDS ***)
(* The following keywords are defined:
   - let: Assignment keyword
   - inherit: Inheritance keyword (in contexts of "let")

   Parsing: NYI
*)
assignment-keyword = "let";
inheritance-keyword = "inherit";
function-keyword = "fun";
keywords =
   assignment-keyword
   | inheritance-keyword
   | function-keyword;

(*** WHITESPACE ***)
(* Valid Unicode whitespace characters

   Parsing: NYI
*)
whitespace = "\u{0009}"
   | "\u{000A}"
   | "\u{000B}"
   | "\u{000C}"
   | "\u{000D}"
   | "\u{0020}"
   | "\u{0085}"
   | "\u{00A0}"
   | "\u{1680}"
   | "\u{2000}"
   | "\u{2001}"
   | "\u{2002}"
   | "\u{2003}"
   | "\u{2004}"
   | "\u{2005}"
   | "\u{2006}"
   | "\u{2007}"
   | "\u{2008}"
   | "\u{2009}"
   | "\u{200A}"
   | "\u{2028}"
   | "\u{2029}"
   | "\u{202F}"
   | "\u{205F}"
   | "\u{3000}";
(* Characters above in order: 
    \u{0009} = Character tabulation
    \u{000A} = Line feed
    \u{000B} = Line tabulation
    \u{000C} = Form feed
    \u{000D} = Carriage return
    \u{0020} = Space
    \u{0085} = Next line
    \u{00A0} = No-break space
    \u{1680} = Ogham space mark
    \u{2000} = En quad
    \u{2001} = Em quad
    \u{2002} = En space
    \u{2003} = Em space
    \u{2004} = Three-per-em space
    \u{2005} = Four-per-em space
    \u{2006} = Six-per-em space
    \u{2007} = Figure space
    \u{2008} = Punctuation space
    \u{2009} = Thin space
    \u{200A} = Hair space
    \u{2028} = Line separator
    \u{2029} = Paragraph separator
    \u{202F} = Narrow no-break space
    \u{205F} = Medium mathematical space
    \u{3000} = Ideographic space
*)

(*** CHARACTERS ***)
(* Valid character set for naming environments

   Characters are either letters or digits
   Characters may be used in identifiers, granted that they do not clash with reserved keywords

   Parsing: NYI
*)
character = letter | digit;

(* Character arrays

   Example: asdf
            thequickbrownfox
            12345
            a63kgds962üêà
            a

   Character arrays could be identifiers, strings, or numbers

   Parsing: NYI
*)
character-array = character , { character };

(*** DATA TYPES ***)
(* Integers

   Example: 123
            456789
            0

   Integers can be strings, parts of identifiers, or numbers

   Parsing: NYI
*)
integer = digit , { digit };

(* Floating-point numbers

   Example: 0.005
            3.14
            100.0
            005.0

   Floating-point numbers are defined by one or more leading digits, a decimal point ".", and one or more trailing digits
   Any of the digits may be zero
   Leading zeros before the decimal point as well as single zeros after the decimal point are ignored during parsing

   Parsing: NYI
*)
float = digit-zero , { digit-zero } , "." , digit-zero , { digit-zero };

(* Strings

   Strings are enclosed with double quotes
   Strings may contain any character, symbol, whitespace or operator

   Any reserved symbols must be escaped with the escape symbol

   Parsing: NYI
*)
double-quote-string = 
   double-quote ,
   { character | integer | whitespace | generic-symbol | single-quote | ( escape, symbol ) } ,
   double-quote;
single-quote-string =
   single-quote ,
   { character | integer | whitespace | generic-symbol | double-quote | ( escape, symbol ) } ,
   single-quote;

(* Boolean values

   Example: true
            false

   Boolean values are used to represent truth values
   Boolean values are case-sensitive

   Parsing: NYI
*)
boolean = ("t", "r", "u", "e") | ("f", "a", "l", "s", "e");

(* Primitive data types

   Primitive data types are either integers, floating-point numbers, strings, or boolean values

   Parsing: NYI
*)
data-type = integer | float | double-quote-string | single-quote-string | boolean;

(*** IDENTIFIERS ***)
(* Environment identifiers

   Environment identifiers are used to name everything treated as an environment
   Identifiers must start with a letter, followed by zero or more letters, digits or generic symbols
   Identifiers may not contain whitespace characters

   Parsing: NYI
*)
identifier = letter , { character | generic-symbol };

(*** INHERITANCE ***)
(* Inheritance arguments

   Example: (a, b, c) or (*\)
   Note: Example wildcard closing parenthesis escaped for file formatting

   Inheritance arguments tells the environment which objects to inherit from the parent
   Inheritance arguments are surrounded by parentheses
   Objects may be inherited as a comma-separated list or a wildcard '*'
   Whitespace is ignored everywhere
   Inheritance arguments are not considered valid outside of inheritance contexts

   Parsing: NYI
*)
inheritance-argument =
   inheritance-argument-start-operator ,
   { whitespace } ,
   identifier
   | wildcard,
   {
      { whitespace } ,
      separator ,
      { whitespace } ,
      identifier
   } ,
   { whitespace } ,
   inheritance-argument-end-operator;

(* Inherited assignment keyword

   Example: let a inherit (b, c) = { ... };

   Precludes an assignment
   The keyword 'inherit' may be surrounded by one valid whitespace character, but not more than one
   The keyword must be followed by the inheritance arguments
   The keyword not considered valid outside of assignment contexts

   Parsing: NYI
*)
inherited-assignment =
   assignment-keyword ,
   { whitespace } ,
   identifier ,
   { whitespace } ,
   inheritance-keyword ,
   { whitespace } ,
   inheritance-argument;

(*** ASSIGNMENTS ***)
(*TODO: Rewrite function-assignment completely!*)
function-assignment = 
   function-keyword ,
   function-argument-start-operator ,
   { whitespace } ,
   identifier ,
   { whitespace } ,
   "," ,
   {
      { whitespace } ,
      identifier ,
      { whitespace } ,
      ","
   } ,
   { whitespace };

(* Assignment

   Example: let a = { ... };
            let b = 5;
            let c = a;

   An assignment is precluded by the assignment keyword and a valid identifier
   Assignment is done with the assignment operator "="
   The assignment operator may be surrounded by zero or more valid whitespace characters
   Assignments contain either explicit or implicit environments (these can be nested, see definitions above)
   An assignment is terminated by a terminator if it ends with an implicit environment
   An assignment is optionally terminated by a terminator if it ends with an explicit environment

   Recommendation: Always terminate assignments with a terminator

   Parsing: NYI
*)
assignment =
   assignment-keyword
   | inherited-assignment ,
   { whitespace } ,
   identifier ,
   { whitespace } ,
   assignment ,
   { whitespace },
   explicit-environment | implicit-environment;

(*** ENVIRONMENTS ***)
(* Environments

   Environments come in two forms: explicit and implicit
   Explicit environments are surrounded by braces
   Implicit environments occur on assignments without braces
   Environments can contain digits, letters, symbols, whitespace, operators and other environments
   Implicit environments are terminated by a terminator, explicit ones do not require a terminator

   Notes:
   The distinction between implicit and explicit environments is mostly backend, as both are treated the same for scope-related purposes
   Implicit environments are not a complete subset of explicit environments, as the former requires a terminator while the latter does not
   Implicit environments are only used in assignment, and are not valid syntax anywhere else

   Parsing: NYI
*)
explicit-environment =
   environment-start-operator ,
   { whitespace } ,
   { assignment | data-type } ,
   environment-end-operator ,
   [ terminator ];

implicit-environment =
   data-type ,
   { whitespace } ,
   terminator;

